import aws_bootstrap_env

import json
import splunk.admin as admin
import splunksdc.log as logging
from splunklib import client as client
from splunktaucclib.rest_handler.error import RestError
from splunk_ta_aws.common.local_manager import LocalServiceManager
import splunk_ta_aws.common.merge_util as merge_util
import splunk_ta_aws.common.ta_aws_consts as tac

logger = logging.get_module_logger()
FIELDS = ['required_args', 'opt_args', 'group_fields', 'input_name']
IGNORE_FIELDS = ['host', 'start_by_shell', 'host_resolved', 'eai:userName', 'eai:appName']


class BaseInputRestHandler(admin.MConfigHandler):
    """This is the base class for all one-to-many rest handlers, such as aws_cloudwatch, aws_config, and etc.

    By extending this class, simply implementing ```__init__``` function and set all params in ```FIELDS```
    """

    def __init__(self, *args, **kwargs):
        """
        Raises:
            NotImplementedError: in case there is any mandantory param that haven't been set
        """

        for arg in FIELDS:
            if not hasattr(self, arg):
                logger.error('Missing variable %s for handler %s. Please implement __init__ '
                             'and set these variables to self: %s' % (self.input_name, arg, ', '.join(FIELDS)))
                raise NotImplementedError('Please implement __init__ and set these variables to self')

        admin.MConfigHandler.__init__(
            self,
            *args,
            **kwargs
        )

        # Origin endpoint is generated by UCC and renamed by build.py
        # Refer to both build.py and restmap.conf
        self._origin_endpoint = getattr(self, 'origin_endpoint') if hasattr(self, 'origin_endpoint') else self.input_name + '_inputs_rh_ucc'
        self._service = LocalServiceManager(app=tac.splunk_ta_aws, session_key=self.getSessionKey()).get_local_service()
        self._collection = client.Collection(self._service, self._origin_endpoint)

    def setup(self):
        for arg in self.opt_args:
            self.supportedArgs.addOptArg(arg)

        for arg in self.required_args:
            self.supportedArgs.addReqArg(arg)

        return

    def handleList(self, confInfo):
        """List all inputs and merge them by common fields.

        """
        inputs = self._collection.list()

        logger.info("%s: listing %d inputs in total" % (self.input_name, len(inputs)))

        inputs_dict = merge_util.merge_inputs(self.input_name, inputs, self.group_fields)

        logger.info("%s: merged into %d inputs" % (self.input_name, len(inputs_dict)))

        for name, props in inputs_dict.iteritems():
            item = confInfo[name]
            for k, v in props.iteritems():
                # Each field in self.group_fields is a list. Should be dumped into string before send back to client side.
                # TODO: Should we dump them here or inside merge_inputs?
                if k in self.group_fields:
                    item.append(k, json.dumps(v))
                elif k == '_conflict_fields':
                    item.append(k, json.dumps(v))
                else:
                    item.append(k, v)

            item['eai:appName'] = tac.splunk_ta_aws
            item['eai:userName'] = 'nobody'
            item.setMetadata(admin.EAI_ENTRY_ACL, {'owner': 'nobody', 'app': tac.splunk_ta_aws})

        return

    def handleEdit(self, confInfo):
        new_inputs_dict = self._get_inputs_from_req(self.callerArgs)
        (old_inputs_dict, inputs) = self._get_inputs_by_name(self.callerArgs.id)

        if len(new_inputs_dict) == 0 or len(old_inputs_dict) == 0:
            return

        creating_inputs = dict()
        editing_inputs = []
        modified_keys = set()

        # Use the first item in new inputs and old inputs to check whether there is any common fields modification
        common_new_input = new_inputs_dict.itervalues().next()
        for key, value in common_new_input.iteritems():
            # Skip group fields
            if key in self.group_fields:
                continue

            for item in old_inputs_dict.itervalues():
                # Check if there is modification on this key
                if (key not in item) or (value != item[key]):
                    modified_keys.add(key)

        logger.info("%s: the following common fields are modified (%s)" % (self.input_name, modified_keys))

        # In case of `{disabled: 1}`, there is no group fields.
        has_group_fields = True
        for key in self.group_fields:
            if key not in common_new_input:
                has_group_fields = False
                break

        logger.info('has_group_fields = %s' % str(has_group_fields))

        if has_group_fields:
            # Iterate over all new inputs to figure out which inputs should be added
            for name, value in new_inputs_dict.iteritems():
                matched_input = self._find_input_by_value(value, old_inputs_dict)

                # If the new input exists in the old inputs, then it should be kept (pop from old_inputs_dict).
                # Any remaining inputs in old_inputs_dict will be removed
                #
                # If the new input does not exist, then put it to the creating_inputs
                if matched_input:
                    old_inputs_dict.pop(matched_input, None)
                    editing_inputs.append(matched_input)
                else:
                    creating_inputs[name] = value
        else:
            # No group field change -> No creating and removing -> Every inputs should be edited.
            editing_inputs = old_inputs_dict.keys()
            old_inputs_dict = dict()

        creating_count = len(creating_inputs)
        edit_count = len(editing_inputs) if len(modified_keys) > 0 else 0
        removing_count = len(old_inputs_dict)
        logger.info("%s: there are %s create, %s edit, and %s remove" % (self.input_name, creating_count, edit_count, removing_count))

        logger.debug(old_inputs_dict)
        logger.debug(editing_inputs)
        logger.debug(creating_inputs)

        # The order HAS to be Remove -> Edit -> Create
        self._remove_inputs(old_inputs_dict)
        self._edit_inputs(inputs, editing_inputs, common_new_input, modified_keys)
        self._create_inputs(creating_inputs)

        return

    def handleCreate(self, confInfo):
        """Create inputs.
        """

        name = self.callerArgs.id
        (old_inputs, temp) = self._get_inputs_by_name(name)

        if len(old_inputs) > 0:
            raise RestError(
                400,
                ' Name "%s" is already in use' % name
            )

        inputs_dict = self._get_inputs_from_req(self.callerArgs)

        self._create_inputs(inputs_dict)

        return

    def handleRemove(self, confInfo):
        """Remove a group of inputs based on name
        """
        logger.info('%s: removing inputs (%s)' % (self.input_name, self.callerArgs.id))

        (inputs_dict, inputs) = self._get_inputs_by_name(self.callerArgs.id)

        self._remove_inputs(inputs_dict)

        return

    def _create_inputs(self, inputs_dict):
        """ Create inputs

        Args:
            inputs_dict (dict): The inputs to be created. The key of dict is the input name.

        Returns:

        """
        if len(inputs_dict) == 0:
            return

        for index, (name, value) in enumerate(inputs_dict.iteritems(), 1):
            try:
                logger.info('%s: creating %s/%s input (%s)...' % (self.input_name, index, len(inputs_dict), name))
                self._collection.create(name, **value)
            except Exception as err:
                logger.error('%s: error when creating input (%s). input dump (%s)' % (self.input_name, name, str(value)))

        # TODO: Add retry here.
        return

    def _remove_inputs(self, inputs_dict):
        """ Remove inputs

        Args:
            inputs_dict (dict): The inputs to be removed. The key of dict is the input name.

        """
        if len(inputs_dict) == 0:
            return

        for index, (name, value) in enumerate(inputs_dict.iteritems(), 1):
            try:
                logger.info('%s: removing %s/%s input (%s)...' % (self.input_name, index, len(inputs_dict), name))
                self._collection.delete(name)
            except Exception as err:
                logger.error('%s: error when removing input (%s). input dump (%s)' % (self.input_name, name, value))

        # TODO: Add retry here.
        return

    def _edit_inputs(self, inputs, editing_inputs, input_template, modified_keys):
        """ This method is used to update common fields for all inputs.

        Args:
            inputs (list): The list of input entities

            editing_inputs (list): The list of input names which will be edited

            input_template (dict): The template of new input which contains the updated value for each common fields

            modified_keys (list): List of keys which will be updated

        Returns:

        """
        if len(modified_keys) == 0 or len(editing_inputs) == 0 or len(inputs) == 0:
            return

        for index, (name) in enumerate(editing_inputs, 1):
            entity = next(x for x in inputs if x.name == name)

            updated_dict = merge_util.copy_content(self.input_name, entity)

            # This is a temp solution since those ignore fields should be added to spec
            for k in IGNORE_FIELDS:
                updated_dict.pop(k, None)

            for k in modified_keys:
                updated_dict[k] = input_template[k]

            # https://jira.splunk.com/browse/ADDON-12880
            # UCC handles `disabled` field separately. If `disabled` field is provided, then other fields will be ignored.
            if 'disabled' not in modified_keys:
                updated_dict.pop('disabled')

            try:
                logger.info('%s: editing %s/%s input (%s)...' % (self.input_name, index, len(editing_inputs), name))
                entity.update(**updated_dict)
            except Exception as err:
                logger.error('%s: error when editing input (%s). input dump (%s)' % (self.input_name, name, updated_dict))

        return

    def _get_inputs_from_req(self, req):
        """ Get the inputs from frontend request.
        The frontend side will always send one input. However, it will be separated into a few inputs
        based on the group fields.

        Args:
            req: The request (confInfo)

        Returns:
            (dict): The separated inputs dict

        """
        origin_input = dict()

        for k in self.opt_args:
            if k in req:
                origin_input[k] = req[k][0]

        for k in self.required_args:
            if k in req:
                origin_input[k] = req[k][0]

        for k in origin_input:
            if origin_input[k] is None:
                origin_input[k] = ""

        inputs_dict = merge_util.separate_inputs(req.id, origin_input, self.group_fields)

        return inputs_dict

    def _get_inputs_by_name(self, name):
        """ Get the inputs and entities based on input name.

        Args:
            name: The name of input

        Returns:
            (dict, list): The dict of inputs and the original input list (entities)

        """

        inputs = self._collection.list()

        logger.info('%s: %d inputs in total. filtering by name (%s)...' % (self.input_name, len(inputs), name))

        inputs_dict = merge_util.match_inputs(self.input_name, inputs, name)

        logger.info('%s: %d inputs after filtering.' % (self.input_name, len(inputs_dict)))

        return (inputs_dict, inputs)

    def _find_input_by_value(self, value, inputs_dict):
        """ Get the input from a list based on fields

        Returns:
            (string): The name of input
        """

        for name, input_value in inputs_dict.iteritems():
            matched = True
            for key in self.group_fields:
                if input_value.get(key, '') != value[key]:
                    matched = False
                    break

            if matched:
                return name

        return None
